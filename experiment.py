import os
from collections import OrderedDict, defaultdict
from glob import glob
from typing import Callable, Union

import cv2
import numpy as np
from skimage.color import rgba2rgb
from stardist.plot import render_label

from codex.helper import CHANNEL_NUM, DEFAULT_CHANNEL


def get_x_and_y(name):
    x, y = os.path.splitext(name)[0].split("_")[-2:]
    return int(x), int(y)


class Segmentation:
    def __init__(self, path: str):
        self.path = os.path.normpath(path)
        self.index = {}
        self._index_files()

        self.slides = {}

    def __getitem__(self, item: str):
        return self.index[item]

    def _index_files(self):
        """
        Indexes the files in folders generated by the neural network.
        """
        # get source images
        source_files = glob(os.path.join(self.path, "**/*.png"), recursive=True)

        self.index[None] = {
            get_x_and_y(f): f
            for f in sorted(source_files, key=lambda x: get_x_and_y(x)[::-1])
        }

        segmented_path = os.path.join(
            os.path.dirname(self.path), os.path.basename(self.path) + "_segmented"
        )

        sub_dir = [
            p
            for p in os.listdir(segmented_path)
            if os.path.isdir(os.path.join(segmented_path, p))
        ]

        for p in sub_dir:
            sub_index = OrderedDict()
            for f in sorted(
                os.listdir(os.path.join(segmented_path, p)),
                key=lambda x: get_x_and_y(x)[::-1],
            ):
                sub_index[get_x_and_y(f)] = os.path.join(segmented_path, p, f)
            self.index[p] = sub_index

    def _restore(self, name: Union[None, str] = None):
        """
        Restores tiles to a full slide.
        """
        x_max, y_max = np.array(list(self[name].keys())).max(axis=0)

        tiles = {}
        max_number = 0

        for (x, y), path in self[name].items():
            tile = cv2.imread(path, -1)
            if os.path.splitext(path)[1] == ".tif":
                # print(x, y, max_number, tile.max())
                tile = tile.astype(np.int32)
                adjusted_tile = (tile + max_number) * (tile > 0)
                if adjusted_tile.max() > 0:
                    max_number = adjusted_tile.max()

                tiles[(x, y)] = adjusted_tile.copy()
            else:
                tiles[(x, y)] = tile

        long_tiles = []
        for y in range(y_max + 1):
            long_tiles.append([])
            for x in range(x_max + 1):
                long_tiles[-1].append(tiles[(x, y)])

        long_tiles = [np.hstack(i) for i in long_tiles]
        return np.vstack(long_tiles)

    def keys(self):
        return self.index.keys()

    # def get_tile(self, x: int, y: int, name: Union[None, str] = None):
    #     """
    #     Returns a tile from name.
    #     """
    #     return cv2.imread(self[name][(x, y)], -1)

    # def get_slide(self, name: Union[None, str] = None):
    #     """
    #     Returns the full slide and caches them.
    #     """
    #     if name in self.slides:
    #         return self.slides[name]

    #     self.slides[name] = self._restore(name)
    #     return self.slides[name]

    # def get_tile_overlay(
    #     self,
    #     x: int,
    #     y: int,
    #     original: Union[None, np.ndarray] = None,
    #     name: str = "lgbm_test_sub2",
    #     to_rgb: bool = True,
    # ) -> np.ndarray:
    #     if original is None:
    #         original = self.get_tile(x, y, original)

    #     label = self.get_tile(x, y, name)
    #     overlay = render_label(label, img=original)

    #     if to_rgb:
    #         return rgba2rgb(overlay)

    #     return overlay


class Slide:
    def __init__(
        self,
        img,
        x_tile_size: int = 128,
        y_tile_size: int = 128,
        preprocess_tile: Callable = lambda x: x,
        offset: Union[int, None] = None,
    ):
        self.img = img
        self.x_tile_size = x_tile_size
        self.y_tile_size = y_tile_size
        self.preprocess_tile = preprocess_tile
        self.offset = offset

        self.tiles = defaultdict(dict)

        for channel in CHANNEL_NUM.keys():
            self._split(channel)

    def __getitem__(self, item):
        raise NotImplementedError

    def _split(self, name: Union[None, str] = None):
        """
        Splits the raw image into tiles. The oppposite of '_restore'.
        """
        img = self.img[CHANNEL_NUM[name], 0 if name == DEFAULT_CHANNEL else 1]

        if self.offset is not None:
            img = img[self.offset :, self.offset :]

        # if (x_tile_size is not None) and (y_tile_size is not None):
        x_tiles_cnt = img.shape[1] // self.x_tile_size
        y_tiles_cnt = img.shape[0] // self.y_tile_size
        # if (x_tiles_cnt is not None) and (y_tiles_cnt is not None):
        x_ticks = np.linspace(0, img.shape[1], x_tiles_cnt + 1).astype(int)
        y_ticks = np.linspace(0, img.shape[0], y_tiles_cnt + 1).astype(int)

        tiles = []
        tile_names = []

        for x_num, x in enumerate(zip(x_ticks[:-1], x_ticks[1:])):
            for y_num, y in enumerate(zip(y_ticks[:-1], y_ticks[1:])):
                im = img[y[0] : y[1], x[0] : x[1]]
                im = self.preprocess_tile(im)
                tiles.append(im)
                tile_names.append((x_num, y_num))

        self.tiles[name] = dict(zip(tile_names, tiles))

    # def get_tile(self, x: int, y: int, name: Union[None, str] = None):
    #     """
    #     Returns a tile from name.
    #     """
    #     return self.tiles[name][(x, y)]

    # def get_slide(self, name: Union[None, str] = None):
    #     if name is None:
    #         return self.img[0, 0]
    #     return self.img[CHANNEL_NUM[name], 1]


class Codex(Segmentation, Slide):
    def __init__(self, path, img, x_tile_size=128, y_tile_size=128, offset=None):
        Segmentation.__init__(self, path)
        Slide.__init__(
            self, img, x_tile_size=x_tile_size, y_tile_size=y_tile_size, offset=offset
        )

    def get_tile(self, x, y, name=DEFAULT_CHANNEL):
        if name in self.tiles.keys() and (x, y) in self.tiles[name]:
            return self.tiles[name][(x, y)]

        img = cv2.imread(self[name][(x, y)], -1)
        self.tiles[name][(x, y)] = img

        return img

    def get_slide(self, name: Union[None, str] = DEFAULT_CHANNEL):
        """
        Returns the full slide and caches them.
        """
        if name in CHANNEL_NUM.keys():
            return self.img[CHANNEL_NUM[name], 0 if name == DEFAULT_CHANNEL else 1]

        if name in self.slides:
            return self.slides[name]

        self.slides[name] = self._restore(name)

        return self.slides[name]

    def get_tile_overlay(
        self,
        x: int,
        y: int,
        name: Union[None, np.ndarray] = DEFAULT_CHANNEL,
        segmentation: str = "lgbm_test_sub2",
        to_rgb: bool = True,
    ) -> np.ndarray:
        """
        Prediction overlay tiles.
        """
        background = self.get_tile(x, y, name)
        overlay = self.get_tile(x, y, segmentation)
        labeled = render_label(overlay, img=background)

        if to_rgb:
            return rgba2rgb(labeled)

        return labeled

    def get_slide_overlay(
        self,
        x: int,
        y: int,
        name: Union[None, np.ndarray] = DEFAULT_CHANNEL,
        segmentation: str = "lgbm_test_sub2",
        to_rgb: bool = True,
    ) -> np.ndarray:
        """
        Prediction overlay tiles.
        """
        background = self.get_slide(name)
        overlay = self.get_slide(segmentation)
        labeled = render_label(overlay, img=background)

        if to_rgb:
            return rgba2rgb(labeled)

        return labeled

    def get_border_cells(self):
        """
        Returns the ids from cells that touched the border of slide.
        """
        # Refactor (?)
        x_max, y_max = np.array(list(self["lgbm_test_sub2"].keys())).max(axis=0)

        long_tiles = []
        for y in range(y_max + 1):
            long_tiles.append([])
            for x in range(x_max + 1):
                tile = np.zeros_like(self.get_tile(x, y, name="lgbm_test_sub2"))
                # print(tile.shape)
                tile[0, :] = 1
                tile[-1, :] = 1
                tile[:, 0] = 1
                tile[:, -1] = 1
                long_tiles[-1].append(tile)

        long_tiles = [np.hstack(i) for i in long_tiles]
        full_tiles = np.vstack(long_tiles)
        m, n = np.where(full_tiles == 1)
        slide = self.get_slide("lgbm_test_sub2")

        cell_ids = np.unique(slide[m, n])
        return cell_ids[cell_ids > 0]
